"""
Output generation functionality for Grid-Based Pre-placement Tool
Handles TCL script generation and failed constraint reporting
"""


class OutputGenerator:
    """Mixin class for output generation operations"""

    def generate_tcl_script(self, filepath: str):
        """
        Generate Innovus TCL script.
        Groups are created for both close_to_target and pipe constraints.

        Args:
            filepath: Path to output TCL file
        """
        with open(filepath, 'w') as f:
            # Write header
            f.write("# Pre-placement TCL Script\n")
            f.write("# Generated by Grid-Based Placer\n")
            f.write(f"# Grid Size: {self.grid_size} um\n")
            f.write("\n")

            # Process all groups (from both close_to_target and pipe)
            for name, data in self.placements.items():
                if data['type'] == 'group':
                    region = data['region']

                    # Write deleteInstGroup command
                    f.write(f"deleteInstGroup {name}\n")

                    # Write createInstGroup command with region
                    f.write(f"createInstGroup {name} -region "
                           f"{region.llx:.2f} {region.lly:.2f} "
                           f"{region.urx:.2f} {region.ury:.2f}\n")

                    # Add instances to group
                    instances = " ".join(data['instances'])
                    f.write(f"addInstToInstGroup {name} {{ {instances} }}\n")
                    f.write("\n")

            # Process single instances (should only be from close_to_target now)
            for name, data in self.placements.items():
                if data['type'] == 'instance':
                    pos = data['position']
                    f.write(f"placeInstance {name} "
                           f"{pos.x:.2f} {pos.y:.2f} -softFixed\n")
                    f.write("\n")

            # Add footer comment if there were any placements
            if self.placements:
                f.write("# End of pre-placement script\n")
                f.write(f"# Total groups placed: {sum(1 for d in self.placements.values() if d['type'] == 'group')}\n")
                f.write(f"# Total single instances placed: {sum(1 for d in self.placements.values() if d['type'] == 'instance')}\n")

    def save_failed_list(self, filepath: str):
        """
        Save list of failed constraints to file.

        Args:
            filepath: Path to output failed list file
        """
        with open(filepath, 'w') as f:
            # Write header
            f.write("# Failed Constraints List\n")
            f.write("# Generated by Grid-Based Placer\n")
            f.write(f"# Grid Size: {self.grid_size} um\n")
            f.write("#" + "="*70 + "\n")
            f.write("\n")

            if self.failed_constraints:
                # Write summary
                f.write(f"# Total failed constraints: {len(self.failed_constraints)}\n")
                f.write("\n")

                # Write each failed constraint
                for idx, item in enumerate(self.failed_constraints, 1):
                    f.write(f"# Failure {idx}:\n")
                    f.write(f"{item}\n")
                    f.write("\n")

                # Add summary by failure type if there are many failures
                if len(self.failed_constraints) > 5:
                    f.write("#" + "="*70 + "\n")
                    f.write("# Summary of Failure Types:\n")

                    # Count different failure types
                    failure_types = {}
                    for item in self.failed_constraints:
                        if "not found" in item.lower():
                            failure_type = "Target not found"
                        elif "no free space" in item.lower() or "cannot allocate" in item.lower():
                            failure_type = "No free space available"
                        elif "cannot find a path" in item.lower() or "path blocked" in item.lower():
                            failure_type = "Path blocked"
                        elif "area" in item.lower() and "smaller than required" in item.lower():
                            failure_type = "Insufficient area"
                        elif "processing error" in item.lower():
                            failure_type = "Processing error"
                        else:
                            failure_type = "Other"

                        failure_types[failure_type] = failure_types.get(failure_type, 0) + 1

                    # Write failure type summary
                    for failure_type, count in sorted(failure_types.items(),
                                                     key=lambda x: x[1], reverse=True):
                        f.write(f"#   {failure_type}: {count}\n")
            else:
                # No failed constraints
                f.write("# No failed constraints\n")
                f.write("# All constraints were successfully processed\n")

